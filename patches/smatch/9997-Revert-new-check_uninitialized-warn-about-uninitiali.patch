From: Sven Eckelmann <sven@narfation.org>
Date: Mon, 29 Jan 2018 15:54:01 +0100
Subject: [PATCH] Revert "*new* check_uninitialized: warn about uninitialized variables"

This reverts commit 2c46548d84a31432925a2c6dd9fc49306625e576.
---
 check_list.h                                  |   1 -
 check_uninitialized.c                         | 362 --------------------------
 smatch_data/kernel.ignore_uninitialized_param |  98 -------
 3 files changed, 461 deletions(-)
 delete mode 100644 check_uninitialized.c
 delete mode 100644 smatch_data/kernel.ignore_uninitialized_param

diff --git a/check_list.h b/check_list.h
index 5e0d4a0848ea8c0d80d2ca7f05530f2dc7594414..b93078aec11c12e00939d2c68c5f3c8fc8e63485 100644
--- a/check_list.h
+++ b/check_list.h
@@ -146,7 +146,6 @@ CK(check_indenting)
 CK(check_unreachable)
 CK(check_no_if_block)
 CK(check_buffer_too_small_for_struct)
-CK(check_uninitialized)
 CK(check_signed_integer_overflow_check)
 CK(check_continue_vs_break)
 CK(check_impossible_mask)
diff --git a/check_uninitialized.c b/check_uninitialized.c
deleted file mode 100644
index 84cbe04ad05fe57c210bced2bf482724cc0ccf36..0000000000000000000000000000000000000000
--- a/check_uninitialized.c
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- * Copyright (C) 2014 Oracle.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see http://www.gnu.org/copyleft/gpl.txt
- */
-
-#include "smatch.h"
-#include "smatch_slist.h"
-#include "smatch_extra.h"
-
-static int my_id;
-
-STATE(uninitialized);
-STATE(initialized);
-
-static void pre_merge_hook(struct sm_state *sm)
-{
-	if (is_impossible_path())
-		set_state(my_id, sm->name, sm->sym, &initialized);
-}
-
-static void mark_members_uninitialized(struct symbol *sym)
-{
-	struct symbol *struct_type, *tmp, *base_type;
-	char buf[256];
-
-	struct_type = get_real_base_type(sym);
-	FOR_EACH_PTR(struct_type->symbol_list, tmp) {
-		if (!tmp->ident)
-			continue;
-		base_type = get_real_base_type(tmp);
-		if (!base_type ||
-		    base_type->type == SYM_STRUCT ||
-		    base_type->type == SYM_ARRAY ||
-		    base_type->type == SYM_UNION)
-			continue;
-		snprintf(buf, sizeof(buf), "%s.%s", sym->ident->name, tmp->ident->name);
-		set_state(my_id, buf, sym, &uninitialized);
-	} END_FOR_EACH_PTR(tmp);
-}
-
-static void match_declarations(struct symbol *sym)
-{
-	struct symbol *type;
-
-	if (sym->initializer)
-		return;
-
-	type = get_real_base_type(sym);
-	/* Smatch is crap at tracking arrays */
-	if (type->type == SYM_ARRAY)
-		return;
-	if (type->type == SYM_UNION)
-		return;
-	if (sym->ctype.modifiers & MOD_STATIC)
-		return;
-
-	if (!sym->ident)
-		return;
-
-	if (type->type == SYM_STRUCT) {
-		mark_members_uninitialized(sym);
-		return;
-	}
-
-	set_state(my_id, sym->ident->name, sym, &uninitialized);
-}
-
-static void extra_mod_hook(const char *name, struct symbol *sym, struct expression *expr, struct smatch_state *state)
-{
-	if (!sym || !sym->ident)
-		return;
-	if (strcmp(name, sym->ident->name) != 0)
-		return;
-	set_state(my_id, name, sym, &initialized);
-}
-
-static void match_assign(struct expression *expr)
-{
-	struct expression *right;
-
-	right = strip_expr(expr->right);
-	if (right->type == EXPR_PREOP && right->op == '&')
-		set_state_expr(my_id, right->unop, &initialized);
-}
-
-static int is_initialized(struct expression *expr)
-{
-	struct sm_state *sm;
-
-	expr = strip_expr(expr);
-	if (expr->type != EXPR_SYMBOL)
-		return 1;
-	sm = get_sm_state_expr(my_id, expr);
-	if (!sm)
-		return 1;
-	if (!slist_has_state(sm->possible, &uninitialized))
-		return 1;
-	return 0;
-}
-
-static void match_dereferences(struct expression *expr)
-{
-	char *name;
-
-	if (parse_error)
-		return;
-
-	if (expr->type != EXPR_PREOP)
-		return;
-	if (is_impossible_path())
-		return;
-	if (is_initialized(expr->unop))
-		return;
-
-	name = expr_to_str(expr->unop);
-	sm_msg("error: potentially dereferencing uninitialized '%s'.", name);
-	free_string(name);
-
-	set_state_expr(my_id, expr->unop, &initialized);
-}
-
-static void match_condition(struct expression *expr)
-{
-	char *name;
-
-	if (parse_error)
-		return;
-
-	if (is_impossible_path())
-		return;
-
-	if (is_initialized(expr))
-		return;
-
-	name = expr_to_str(expr);
-	sm_msg("error: potentially using uninitialized '%s'.", name);
-	free_string(name);
-
-	set_state_expr(my_id, expr, &initialized);
-}
-
-static void match_call(struct expression *expr)
-{
-	struct expression *arg;
-	char *name;
-
-	if (parse_error)
-		return;
-
-	if (is_impossible_path())
-		return;
-
-	FOR_EACH_PTR(expr->args, arg) {
-		if (is_initialized(arg))
-			continue;
-
-		name = expr_to_str(arg);
-		sm_msg("warn: passing uninitialized '%s'", name);
-		free_string(name);
-
-		set_state_expr(my_id, arg, &initialized);
-	} END_FOR_EACH_PTR(arg);
-}
-
-static int param_used_callback(void *found, int argc, char **argv, char **azColName)
-{
-	*(int *)found = 1;
-	return 0;
-}
-
-static int member_is_used(struct expression *call, int param, char *printed_name)
-{
-	int found;
-
-	/* for function pointers assume everything is used */
-	if (call->fn->type != EXPR_SYMBOL)
-		return 0;
-
-	found = 0;
-	run_sql(&param_used_callback, &found,
-		"select * from call_implies where %s and type = %d and parameter = %d and key = '%s';",
-		get_static_filter(call->fn->symbol), PARAM_USED, param, printed_name);
-	return found;
-}
-
-static void match_call_struct_members(struct expression *expr)
-{
-	struct symbol *type, *sym;
-	struct expression *arg;
-	struct sm_state *sm;
-	char *arg_name;
-	char buf[256];
-	int param;
-
-	return;
-
-	if (parse_error)
-		return;
-
-	param = -1;
-	FOR_EACH_PTR(expr->args, arg) {
-		param++;
-		if (arg->type != EXPR_PREOP || arg->op != '&')
-			continue;
-		type = get_type(arg->unop);
-		if (!type || type->type != SYM_STRUCT)
-			continue;
-		arg_name = expr_to_var_sym(arg->unop, &sym);
-		if (!arg_name || !sym)
-			goto free;
-		FOR_EACH_MY_SM(my_id, __get_cur_stree(), sm) {
-			if (sm->sym != sym)
-				continue;
-			if (!slist_has_state(sm->possible, &uninitialized))
-				continue;
-			snprintf(buf, sizeof(buf), "$->%s", sm->name + strlen(arg_name) + 1);
-			if (!member_is_used(expr, param, buf))
-				goto free;
-			sm_msg("warn: struct member %s is uninitialized", sm->name);
-		} END_FOR_EACH_SM(sm);
-
-free:
-		free_string(arg_name);
-	} END_FOR_EACH_PTR(arg);
-}
-
-static int is_being_modified(struct expression *expr)
-{
-	struct expression *parent;
-	struct statement *stmt;
-
-	parent = expr_get_parent_expr(expr);
-	if (!parent)
-		return 0;
-	while (parent->type == EXPR_PREOP && parent->op == '(')
-		parent = expr_get_parent_expr(parent);
-	if (parent->type == EXPR_PREOP && parent->op == '&')
-		return 1;
-	if (parent->type == EXPR_ASSIGNMENT && expr_equiv(parent->left, expr))
-		return 1;
-
-	stmt = last_ptr_list((struct ptr_list *)big_statement_stack);
-	if (stmt && stmt->type == STMT_ASM)
-		return 1;
-
-	return 0;
-}
-
-static void match_symbol(struct expression *expr)
-{
-	char *name;
-
-	if (parse_error)
-		return;
-
-	if (is_impossible_path())
-		return;
-
-	if (is_initialized(expr))
-		return;
-
-	if (is_being_modified(expr))
-		return;
-
-	name = expr_to_str(expr);
-	sm_msg("error: uninitialized symbol '%s'.", name);
-	free_string(name);
-
-	set_state_expr(my_id, expr, &initialized);
-}
-
-static void match_untracked(struct expression *call, int param)
-{
-	struct expression *arg;
-
-	arg = get_argument_from_call_expr(call->args, param);
-	arg = strip_expr(arg);
-	if (!arg || arg->type != EXPR_PREOP || arg->op != '&')
-		return;
-	arg = strip_expr(arg->unop);
-	set_state_expr(my_id, arg, &initialized);
-}
-
-static void match_ignore_param(const char *fn, struct expression *expr, void *_arg_nr)
-{
-	int arg_nr = PTR_INT(_arg_nr);
-	struct expression *arg;
-
-	arg = get_argument_from_call_expr(expr->args, arg_nr);
-	arg = strip_expr(arg);
-	if (!arg)
-		return;
-	if (arg->type != EXPR_PREOP || arg->op != '&')
-		return;
-	arg = strip_expr(arg->unop);
-	set_state_expr(my_id, arg, &initialized);
-}
-
-static void register_ignored_params_from_file(void)
-{
-	char name[256];
-	struct token *token;
-	const char *func;
-	char prev_func[256];
-	int param;
-
-	memset(prev_func, 0, sizeof(prev_func));
-	snprintf(name, 256, "%s.ignore_uninitialized_param", option_project_str);
-	name[255] = '\0';
-	token = get_tokens_file(name);
-	if (!token)
-		return;
-	if (token_type(token) != TOKEN_STREAMBEGIN)
-		return;
-	token = token->next;
-	while (token_type(token) != TOKEN_STREAMEND) {
-		if (token_type(token) != TOKEN_IDENT)
-			return;
-		func = show_ident(token->ident);
-
-		token = token->next;
-		if (token_type(token) != TOKEN_NUMBER)
-			return;
-		param = atoi(token->number);
-
-		add_function_hook(func, &match_ignore_param, INT_PTR(param));
-
-		token = token->next;
-	}
-	clear_token_alloc();
-}
-
-void check_uninitialized(int id)
-{
-	my_id = id;
-
-	add_hook(&match_declarations, DECLARATION_HOOK);
-	add_extra_mod_hook(&extra_mod_hook);
-	add_hook(&match_assign, ASSIGNMENT_HOOK);
-	add_untracked_param_hook(&match_untracked);
-	add_pre_merge_hook(my_id, &pre_merge_hook);
-
-	add_hook(&match_dereferences, DEREF_HOOK);
-	add_hook(&match_condition, CONDITION_HOOK);
-	add_hook(&match_call, FUNCTION_CALL_HOOK);
-	add_hook(&match_call_struct_members, FUNCTION_CALL_HOOK);
-	add_hook(&match_symbol, SYM_HOOK);
-
-	register_ignored_params_from_file();
-}
diff --git a/smatch_data/kernel.ignore_uninitialized_param b/smatch_data/kernel.ignore_uninitialized_param
deleted file mode 100644
index 38206c438506a51be111f5bb667101327a7e578e..0000000000000000000000000000000000000000
--- a/smatch_data/kernel.ignore_uninitialized_param
+++ /dev/null
@@ -1,98 +0,0 @@
-regmap_read 2
-regmap_fields_read 2
-visorchannel_read 2
-dmam_alloc_coherent 2
-diva_pci_alloc_consistent 2
-read_mos_reg 3
-adp5520_read 2
-gameport_cooked_read 2
-max3100_sr 1
-sata_scr_read 2
-svia_scr_read 2
-lp8788_read_byte 2
-qla83xx_rd_reg 2
-cciss_read_capacity 2
-cciss_read_capacity 3
-rio_mport_read_config_32 4
-acpi_read 0
-axi_clkgen_mmcm_read 2
-intel_msic_irq_read 2
-pci_user_read_config_word 2
-ec_read 1
-sony_call_snc_handle 2
-pci_user_read_config_word 2
-read_reg_fp 2
-vid_blk_read_word 2
-mc417_memory_read 2
-stv06xx_read_sensor 2
-lm90_read_reg 2
-read_mii_word 3
-read_eprom_word 2
-generic_ocp_read 2
-lan78xx_read_reg 2
-com20020_copy_from_card 3
-wl3501_get_from_wla 2
-ipw_get_ordinal 2
-generic_ocp_read 3
-et131x_mii_read 2
-ql_mii_read_reg 2
-atl1c_read_phy_dbg 2
-atl2_read_phy_reg 2
-atl1_read_phy_reg 2
-pch_gbe_hal_read_phy_reg 2
-t1_tpi_read 2
-rio_local_read_config_32 2
-acpi_smbus_read 4
-pci_read_config_dword 2
-viafb_i2c_readbyte 3
-bap_read 1
-of_property_read_u32 2
-of_property_read_u8 2
-of_property_read_u16 2
-intel_gvt_hypervisor_read_gpa 2
-cs5536_read 1
-__amd64_read_pci_cfg_dword 2
-e1e_rphy 2
-imx_phy_reg_read 0
-chipio_read 0
-had_read_register 1
-qcaspi_read_register 2
-mv88e6xxx_g2_read 2
-b53_read8 3
-b53_read16 3
-b53_read32 3
-b53_read48 3
-b53_read64 3
-dvbtqam_get_acc_pkt_err 1
-ch7xxx_readb 2
-ivch_read 2
-tvp7002_read 2
-rtsx_pci_read_register 2
-rtsx_usb_ep0_read_register 2
-__t1_tpi_read 2
-smsc95xx_read_reg 2
-pci_user_read_config_dword 2
-da903x_read 2
-rio_read_config_8 2
-rio_read_config_16 2
-rio_read_config_32 2
-__ad7280_read32 1
-rtsx_read_cfg_dw 3
-lola_read_param 3
-soc_dapm_read 2
-read_nic_byte 2
-amd_smn_read 2
-meson_ao_cec_read 2
-pci_read_config_byte 2
-pci_read_config_word 2
-i40e_read_nvm_word 2
-stk_camera_read_reg 2
-cnl_get_buf_trans_edp 1
-cnl_get_buf_trans_dp 1
-intel_ddi_get_buf_trans_edp 1
-intel_ddi_get_buf_trans_dp 1
-cnl_get_buf_trans_hdmi 1
-iosf_mbi_read 3
-lola_codec_read 5
-chipio_read 2
-pcxhr_write_io_num_reg_cont 3
